---
tags:
  - Arquitetura de Computadores
---
### Introducao a AC (14 Slides)
  - Introducao 
    - ENGIMA
    - COLOSSUS
    - ENIAC - Inicio em 43 to 46
    - EDVAC - Contrato de Inicio feito em 1
    - Conceito de : **Programas Fixo**
  - Definicao
  - Alguns Conteudos
### Principios de Projeto (24 Slides)
  - Historico
  - Von Neumann
  - Mini e Super CPUs
  - Personagens
### ISA e Arquitetura RISC (30 Slides)
  - ISA --> Industry Standard Architecture 
  - Desempenho e propiedades do nivel ISA
  - RISC --> Reduced Instruction Set Computer 
### MIPS - Microprocessor without Interlocked Pipeline Stages (27 Slides)
  - Arrays
    - Load and Store
    - Acesso por variavel

  - Tipos de Instrucoes
  - Operacoes executadas pelo Hardware
  - Operandos do Hardware
  - Arrays
  - Memoria
### MIPS: Desvios
  - Introducao
  - Desvios 
  - Loops

### Multiplicação, divisão e Linguagem de Máquina (11 Slides)
  - Multiplicacao
  - Divisao
  - Campos
  - Valores
  - Registradores

### Metricas de Desempenho e Lei de Amdahl
  - Uma solucao Criativa
  - Metricas de Desempenho
  - Principios de projeto
  - Lei de Amdahl
  - A equacao de desempenho do processador
  - Equacao de desempenho vs. Lei de Amdahl
<br><br>
## [Instruction Set Architectures](https://www.youtube.com/watch?v=1KTW32xSs_k)  (13:34) (0612 TV w/ NERDfirst) 
- 1:14 --> Why do we need ISA, a higher level? away from logical implementation... **Abstraction**
- OpCode - Defined what operation the CPU must carry out
- Instructions are implementation dependent (Absttraction)
  - For example if u have an Intel and AMD CPU they can both implement the x86 instruction set
  - But the implementation of them are different
    - Both Intel and AMD chips can power Windows CPUs despite their different construction, as long as they implement x86
    - as long as it understand the same instruction it will give you the same results (1 Level of abstraction)
- 4:20 Memory Allocation 
  - The use of adresses
  - The Concept of an register (the need of cpu to temporaly hold info)
- 5:30 MIPS - Examples
  - 32 Bits in lenght
  - 3 Types (different ways of dividing the instruction)
  - R, I , J
  - OPCode
- J Type (JP)
  - 6 Bits - OpCode
  - 26 Bits - Adrrs to JumpTo
- I Type (Instruction w/ IMEDIATE Value)
  - 6 Bits - OPCode
  - 6 Bits - Source Register
  - 6 Bits - Target Register
  - 14 Bits - Immediate Value (Just a Number/Value, no source destination or anything like that)
- R Type
  - 6 Bits - Opcdoe
  - 5 Bits - Source
  - 5 Bits - Target
  - 5 Bits - Destination
  - 5 Bits - Shift Amount
  - `6 Bits - Function`
* 6 Bit OpCode = 2^6 = 64 Combinations

9:30 - How do we get more?
- AnserFunction Bits at the Right Side
  - Answer is (2^6-1) + 2^6 = 127
- R Types always have the same OpCode = 000 000

10:40 - Assembly language

C -> Assembly -> Machine Code(bit strings)
- The more to the right, less abstraction

## [RISC vs CISC](https://www.youtube.com/watch?v=_EKgwOAAWZA)
- R = Reduced
- C = Complex
- ISC = Instruction set Computing

- Both are microprocessor architectures
- RISC uses a small highly optimized set of instructions
- CISC architecture utilizes a specialized set of instructions

* 1 CISC instruction may equals to several RISC instructions

| _CISC_ | _RISC_| 
| --------| :-------|
| Programmer Oriented     | Machine Oriented   | 
| Longer Instructions     | Simpler Instructions     | 
| Shorter Code     | Longer Code    | 
| Emphasis in Hardware     |  Emphasis in Software     | 
| A line maye take Multiple clock cycles    | A line = 1 Clock cycle    | 
| Hard to Pipeline    | Easy to Pipeline |

2:20 Example - Multiplication
- A RISC needs to Use
  - LOAD A,B
  - LOAD A,B
  - PROD A,B
  - STORE A
- When CISC only needs 
  - MULT A,B

- RISC based processor are really comming in Mobile deviced 
  - Mainly cause of power efficiency 
- HowEver most notebooks use the x86 architecure (CISC)
  - Uses microciode, to take advantage of the RISC Pipeline

### RISC AND SISC in the industry
  - The uses are dependent on associated costs 
  - Back when RAM was very expensive, using less was better (CISC came into be)
    - By designing complicated instructions, you could reduce the use of memory and facilitate the program
      - HowEver multiple clock cycles, resulted in high powerUltage

The Solution to this appeared to be the RISC
  - Economic solution
  - SPARK (One of the first Hybrids)

Summary
- Main differnce in their approach to coding
  - CISC = Complex
  - RISC = Simple

- SISC = More programmer friendly